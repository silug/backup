#!/usr/bin/perl -w
#
# $Id: backup,v 1.4 2001/07/10 20:43:07 steve Exp $

use strict;

use FileHandle;
use DirHandle;
use Carp;
use Getopt::Long;
use POSIX qw(pause);
use IO::Handle;

use vars qw($backup_dir $config_file %conf $default_backup_command);
use vars qw(@extraflags @hosts %host $maxchildren @children $done);
use vars qw($debug $verbose $config_dir);

sub read_config_file($$);
sub read_host_conf($);
sub backup($$@);
sub my_system(@);
sub safe_chdir($);
sub debug(@);
sub bold($);

$default_backup_command="rsync -e 'ssh -c blowfish-cbc' -axH"
                      . " HOST:PATH/. ."
                      . " --numeric-ids --timeout=600 --partial"
                      . " --exclude /lost+found/ --exclude '*.mp3'"
		      . " --exclude '*.iso' --exclude core EXTRAFLAGS";
$maxchildren=undef;

GetOptions("extraflags=s"   => \@extraflags,
           "host=s"         => \@hosts,
           "maxchildren=i"  => \$maxchildren,
	   "debug"          => \$debug,
	   "verbose"        => \$verbose,
	   "backupdir=s"    => \$backup_dir,
	   "configfile=s"   => \$config_file,
	   "configdir=s"    => \$config_dir);

$debug=$debug || $ENV{'DEBUG'};

$config_file=$config_file || (($debug ? "" : "/etc/") . "backup.conf");

read_config_file($config_file, \%conf);

$debug=1 if (defined($conf{'debug'}) and
             ($conf{'debug'}==1 or
              $conf{'debug'} eq "yes" or
              $conf{'debug'} eq "on"));

$default_backup_command=$conf{'default command'}
    if (defined($conf{'default command'}));

$backup_dir=$backup_dir || $conf{'backupdir'};
die "No directory specified for backups!\n" if (!$backup_dir);

push(@extraflags, "--verbose --progress")
    if ($debug || ($verbose && -t(STDERR)));

if (!defined($maxchildren))
{
    if (defined($conf{'maxchildren'}))
    {
        $maxchildren=$conf{'maxchildren'};
    }
    else
    {
	$maxchildren=0;
    }
}
$maxchildren=int($maxchildren);
debug "\$maxchildren set to '$maxchildren'";

$config_dir=$config_dir
	    || $conf{'configdir'}
            || (($debug ? "" : "/etc/") . "backup.d");
safe_chdir $config_dir or die "chdir($config_dir) failed: $!\n";
my $dir=new DirHandle "." or die "Failed to open $config_dir: $!\n";
for my $file ($dir->read)
{
    next if ($file=~/^\.\.?$/);

    $host{$file}=read_host_conf($file);
}

if (!keys(%host))
{
    print STDERR "No hosts defined, exiting...\n";
    exit 0;
}

@children=();
$done=0;

$SIG{'CHLD'}=\&reaper;
$SIG{'ALRM'}=sub { debug "Caught SIGALRM"; alarm(30); kill('CHLD', $$); };
for my $signal (qw(HUP INT QUIT TERM CONT TSTP))
{
    $SIG{$signal}=\&kill_em_all;
}

alarm(30);
for my $hostname (@hosts ? @hosts : keys(%host))
{
    last if ($done);

    if ($maxchildren)
    {
        debug "Checking for available slots...";
	while (@children >= $maxchildren)
	{
	    # *FIXME* - A SIGCHLD right now would be a Bad Thing.
	    debug "Waiting for slot to open...";
	    pause; # But after this it would be OK.
	}
	my $pid=fork;
	if ($pid > 0)
	{
	    push(@children, $pid);
	    debug scalar(@children), " children...";
	}
	elsif ($pid == 0)
	{
            for my $signal (qw(TSTP CHLD))
            {
                $SIG{$signal}='DEFAULT';
            }
            for my $signal (qw(HUP INT QUIT TERM CONT))
            {
                #$SIG{$signal}=sub { debug "Child got signal '$_[0]'."; $done=1; $SIG{$_[0]}='DEFAULT'; kill $_[0], $$; };
                #$SIG{$signal}=sub { debug "Child got signal '$_[0]'."; $done=1; };
            }
            debug "[$$] Backing up $hostname...";
            for my $path (keys(%{$host{$hostname}}))
            {
                last if ($done);
                backup($hostname, $path, @{$host{$hostname}->{$path}});
            }
            wait;
	    exit 0;
	}
	else
	{
	    warn "fork() failed: $!";
	}
    }
    else
    {
        debug "Backing up $hostname...";
        for my $path (keys(%{$host{$hostname}}))
        {
            backup($hostname, $path, @{$host{$hostname}->{$path}});
        }
    }
}

if ($maxchildren)
{
    while (@children)
    {
        debug "Waiting for children to exit...";
	pause;
    }
}

debug "Exiting...";

sub read_config_file($$)
{
    my ($config_file, $conf)=@_;

    my $config=new FileHandle "<$config_file"
	or die "Failed to open $config_file: $!\n";

    my $last;
    while (<$config>)
    {
	chomp;
	s/(?<!\\)#.*$//; # Strip comments ("\" escapes "#")
	$_=$last.$_ if ($last);
	if (s/\\\s*$//)
	{
	    $last=$_;
	    next;
	}
	else
	{
	    $last="";
	}
	next if (/^\s*$/); # Skip blank lines

	my ($param,$value)=/^\s*([^=]*?)\s*=\s*(.*?)\s*$/;
	if (!$param)
	{
	    warn "Skipping bogus line $. of $config_file...\n";
	    next;
	}
	warn "Redefining $param! ($config_file line $.)\n"
	    if (defined($conf->{$param}));
	$conf->{$param}=$value;
	debug $param, "=", bold("'"), $value, bold("'");
    }
    close($config);
}

sub read_host_conf($)
{
    my $config_file=shift;

    my $config=new FileHandle "<$config_file"
        or die "Failed to open $config_file: $!\n";

    debug "Reading file '$config_file'...";

    my (%conf,$last);
    while (<$config>)
    {
        chomp;
        s/(?<!\\)#.*$//; # Strip comments ("\" escapes "#")
        $_=$last.$_ if ($last);
        if (s/\\\s*$//)
        {
            $last=$_;
	    next;
        }
        else
        {
            $last="";
        }
        next if (/^\s*$/); # Skip blank lines

        my ($path,@command)=split;
        warn "Re-defining $config_file:$path, line $.\n"
            if (defined($conf{$path}));
        $conf{$path}=[@command];
    }
    close($config);

    return \%conf;
}

sub backup($$@)
{
    my ($hostname,$path,@command)=@_;

    debug "\t$hostname:$path";

    safe_chdir $backup_dir or die "safe_chdir '$backup_dir' failed: $!\n";

    if (!safe_chdir $hostname)
    {
        mkdir $hostname, 0700;
	safe_chdir $hostname or die "safe_chdir '$backup_dir/$hostname': $!\n";
    }

    if (!safe_chdir "./$path")
    {
        debug "need to create './$path'";
        for my $part (split '/', $path)
	{
            next if (!$part);
	    debug "creating '$part'";
	    mkdir $part, 0700;
	    safe_chdir $part
	        or die "safe_chdir '$backup_dir/$hostname/$path: $!\n";
	}
    }

    my $command="@command" || $default_backup_command;

    $command=~s/DEFAULT/$default_backup_command/g;
    if (@extraflags and $command=~/EXTRAFLAGS/)
    {
	my $extraflags="@extraflags";
        $command=~s/EXTRAFLAGS/$extraflags/g;
    }
    else
    {
        $command=~s/\s+EXTRAFLAGS//g;
        $command=~s/EXTRAFLAGS\s+//g;
        $command=~s/EXTRAFLAGS//g;
    }
    $command=~s/HOST/$hostname/g;
    $command=~s/PATH/$path/g;

    debug "Running";
    debug "    $command";
    debug "in $backup_dir/$hostname/$path";
    my $ret=my_system $command;
    if ($ret != 0)
    {
        print STDERR "'$command' failed: ";
        if ($ret == -1)
        {
            print STDERR "$!\n";
        }
        else
        {
            if ($ret & 127)
            {
                print STDERR "exited on signal ", $ret & 127;
                print STDERR ", core dumped" if ($ret & 128);
            }
            else
            {
                print STDERR "exit value ", $ret >> 8;
            }
            print STDERR "\n";
        }
    }
}

sub my_system(@)
{
    my $pid=fork;

    if ($pid > 0)
    {
        @children=($pid);
        waitpid($pid, 0);
	return $?;
    }
    elsif ($pid == 0)
    {
        exec @_ or return -1;
    }
    else
    {
        return -1;
    }
}

sub safe_chdir($)
{
    my $dir=shift;

    if (!$dir)
    {
        carp "empty directory passed to safe_chdir, ignoring";
    }
    else
    {
        chdir $dir;
    }
}

sub debug(@)
{
    return if (!$debug);
    if (!@_)
    {
        print STDERR "\n";
    }
    else
    {
        print STDERR bold("d: "), @_, "\n";
    }
    STDERR->flush;
}

sub bold($)
{
    return @_ if (!-t STDERR);
    return "\033[37;1m" . $_[0] . "\033[0m";
}

sub reaper
{
    for (my $n=0;$n<@children;$n++)
    {
        if (waitpid($children[$n], 1)!=0) # *FIXME* Should be WNOHANG (not 1)
	{
	    debug "[$$] PID $children[$n] exited.";
	    splice(@children, $n, 1);
	}
    }
}

sub kill_em_all
{
    my $sig=$_[0];

    debug "[$$] Got signal '$sig'";

    for my $child (@children)
    {
        debug "[$$] killing PID $child...";
        kill $sig, $child;
    }

    $done=1
        if ($sig eq 'HUP' or $sig eq 'INT' or $sig eq 'QUIT' or $sig eq 'TERM');
}
